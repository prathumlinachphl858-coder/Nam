--==================================================
-- NamX Hub | Rayfield Core
-- Version : v1.6.1
-- Author  : Nam
--==================================================

if getgenv().NamXHubLoaded then
    warn("NamX Hub already loaded")
    return
end
getgenv().NamXHubLoaded = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

--==================================================
-- LOAD RAYFIELD (UI อยู่ก่อนเสมอ)
--==================================================
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

--==================================================
-- CREATE WINDOW
--==================================================
local Window = Rayfield:CreateWindow({
    Name = "NamX Hub",
    LoadingTitle = "NamX Hub",
    LoadingSubtitle = "by Nam",
    ConfigurationSaving = { Enabled = true, FolderName = "NamXHub", FileName = "Config" },
    KeySystem = false
})

--==================================================
-- AIMBOT + HITBOX TAB
--==================================================
local AimbotTab = Window:CreateTab("Aimbot", 4483362458)
AimbotTab:CreateSection("Aimbot & Hitbox")

local AimbotConfig = {
    Enabled = false,
    TargetPart = "Head",
    FOV = 120,
    Smoothness = 0.15,
    WallCheck = true,
    HitboxEnabled = false,
    HitboxSizeHead = 6,
    HitboxSizeBody = 10,
    HitboxTransparency = 0.7
}

local HitboxCache = {}

local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.NumSides = 64
FOVCircle.Filled = false
FOVCircle.Visible = false
FOVCircle.Color = Color3.fromRGB(255,255,255)

local function isVisible(targetPart)
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
    local result = workspace:Raycast(origin, direction, params)
    if result then
        return result.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true
end

local function getClosestTargetInFOV()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Team ~= LocalPlayer.Team then
            local char = player.Character
            local part = char and char:FindFirstChild(AimbotConfig.TargetPart)
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            if part and humanoid and humanoid.Health > 0 then
                if AimbotConfig.WallCheck and not isVisible(part) then continue end
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                    if dist < AimbotConfig.FOV and dist < shortestDistance then
                        shortestDistance = dist
                        closestPlayer = part
                    end
                end
            end
        end
    end
    return closestPlayer
end

local function applyHitbox(player)
    if not AimbotConfig.HitboxEnabled then return end
    if player == LocalPlayer or player.Team == LocalPlayer.Team then return end
    local char = player.Character
    if not char then return end
    local targetPartName = AimbotConfig.TargetPart
    local part = char:FindFirstChild(targetPartName)
    if not part or not part:IsA("BasePart") then return end
    if not HitboxCache[part] then
        HitboxCache[part] = {Size=part.Size,Transparency=part.Transparency,CanCollide=part.CanCollide}
    end
    local size = (targetPartName=="Head") and AimbotConfig.HitboxSizeHead or AimbotConfig.HitboxSizeBody
    part.Size = Vector3.new(size,size,size)
    part.Transparency = AimbotConfig.HitboxTransparency
    part.CanCollide = false
end

local function restoreHitbox()
    for part, data in pairs(HitboxCache) do
        if part and part.Parent then
            part.Size = data.Size
            part.Transparency = data.Transparency
            part.CanCollide = data.CanCollide
        end
    end
    table.clear(HitboxCache)
end

RunService.RenderStepped:Connect(function()
    local screenCenter = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    FOVCircle.Position = screenCenter
    FOVCircle.Radius = AimbotConfig.FOV
    FOVCircle.Visible = AimbotConfig.Enabled

    if AimbotConfig.Enabled then
        local targetPart = getClosestTargetInFOV()
        if targetPart then
            local camPos = Camera.CFrame.Position
            local newCFrame = CFrame.new(camPos, targetPart.Position)
            Camera.CFrame = Camera.CFrame:Lerp(newCFrame, AimbotConfig.Smoothness)
        end
    end

    if AimbotConfig.HitboxEnabled then
        for _, plr in ipairs(Players:GetPlayers()) do applyHitbox(plr) end
    else
        restoreHitbox()
    end
end)

AimbotTab:CreateToggle({Name="Enable Aimbot",CurrentValue=false,Callback=function(v) AimbotConfig.Enabled=v end})
AimbotTab:CreateDropdown({Name="Target Part",Options={"Head","HumanoidRootPart"},CurrentOption="Head",Callback=function(v) AimbotConfig.TargetPart=v end})
AimbotTab:CreateSlider({Name="FOV Size",Range={50,400},Increment=5,CurrentValue=120,Callback=function(v) AimbotConfig.FOV=v end})
AimbotTab:CreateSlider({Name="Smoothness",Range={0.05,1},Increment=0.05,CurrentValue=0.15,Callback=function(v) AimbotConfig.Smoothness=v end})
AimbotTab:CreateToggle({Name="Wall Check",CurrentValue=true,Callback=function(v) AimbotConfig.WallCheck=v end})
AimbotTab:CreateToggle({Name="Enable Hitbox",CurrentValue=false,Callback=function(v) AimbotConfig.HitboxEnabled=v if not v then restoreHitbox() end end})
AimbotTab:CreateSlider({Name="Hitbox Size (Head)",Range={4,20},Increment=1,CurrentValue=AimbotConfig.HitboxSizeHead,Callback=function(v) AimbotConfig.HitboxSizeHead=v end})
AimbotTab:CreateSlider({Name="Hitbox Size (Body)",Range={6,30},Increment=1,CurrentValue=AimbotConfig.HitboxSizeBody,Callback=function(v) AimbotConfig.HitboxSizeBody=v end})

--==================================================
-- VISUAL / ESP TAB
--==================================================
local VisualTab = Window:CreateTab("Visual", 4483362458)
VisualTab:CreateSection("ESP System")

local ESPConfig = {
    Box = false,
    Skeleton = false,
    Line = false,
    Name = false,
    Distance = false,
    HealthBar = false
}

local ESPObjects = {}
local HealthBarObjects = {}
local ESPConnection

local function getTeamColor(player)
    if player.Team == LocalPlayer.Team then
        return Color3.fromRGB(0,255,0)
    else
        return Color3.fromRGB(255,0,0)
    end
end

local function createESP(player)
    if player == LocalPlayer then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end

    local objects = {}
    objects.Box = Drawing.new("Square")
    objects.Box.Thickness = 1
    objects.Box.Filled = false
    objects.Box.Visible = true

    objects.Skeleton = {}
    local parts = {"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand",
                   "RightUpperArm","RightLowerArm","RightHand",
                   "LeftUpperLeg","LeftLowerLeg","LeftFoot",
                   "RightUpperLeg","RightLowerLeg","RightFoot"}
    for _, partName in ipairs(parts) do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Visible = true
        table.insert(objects.Skeleton, {partName, line})
    end

    objects.Line = Drawing.new("Line")
    objects.Line.Thickness = 1
    objects.Line.Visible = true

    objects.NameText = Drawing.new("Text")
    objects.NameText.Size = 13
    objects.NameText.Center = true
    objects.NameText.Outline = true
    objects.NameText.Font = 2
    objects.NameText.Visible = true

    objects.DistanceText = Drawing.new("Text")
    objects.DistanceText.Size = 13
    objects.DistanceText.Center = true
    objects.DistanceText.Outline = true
    objects.DistanceText.Font = 2
    objects.DistanceText.Visible = true

    ESPObjects[player] = objects
end

local function removeESP(player)
    if ESPObjects[player] then
        local obj = ESPObjects[player]
        for k,v in pairs(obj) do
            if type(v)=="table" then
                for _, line in ipairs(v) do line[2]:Remove() end
            else
                v:Remove()
            end
        end
        ESPObjects[player] = nil
    end
end

local function createHealthBar(player)
    if player == LocalPlayer then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local healthBar = Drawing.new("Square")
    healthBar.Thickness = 1
    healthBar.Filled = true
    healthBar.Visible = true
    HealthBarObjects[player] = healthBar
end

local function removeHealthBar(player)
    if HealthBarObjects[player] then
        HealthBarObjects[player]:Remove()
        HealthBarObjects[player] = nil
    end
end

local function updateESP()
    for player,obj in pairs(ESPObjects) do
        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp and humanoid then
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
            local color = getTeamColor(player)

            -- Box
            if obj.Box then
                local size = math.clamp(3000/distance,20,80)
                obj.Box.Size = Vector2.new(size,size)
                obj.Box.Position = Vector2.new(pos.X-size/2,pos.Y-size/2)
                obj.Box.Color = color
                obj.Box.Visible = ESPConfig.Box and onScreen
            end

            -- Skeleton
            if obj.Skeleton and ESPConfig.Skeleton then
                local function getPartPos(name)
                    local p = char:FindFirstChild(name)
                    if p then
                        local screenPos, onScreen = Camera:WorldToViewportPoint(p.Position)
                        return Vector2.new(screenPos.X,screenPos.Y), onScreen
                    end
                    return Vector2.new(0,0), false
                end

                for _, lineData in ipairs(obj.Skeleton) do
                    local fromPos, fromScreen = getPartPos(lineData[1])
                    local toPos = fromPos -- ต่อพาร์ตตาม Skeleton logic
                    lineData[2].From = fromPos
                    lineData[2].To = toPos
                    lineData[2].Color = color
                    lineData[2].Visible = ESPConfig.Skeleton and fromScreen
                end
            end

            -- Line
            if obj.Line then
                local screenCenter = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)
                obj.Line.From = screenCenter
                obj.Line.To = Vector2.new(pos.X,pos.Y)
                obj.Line.Color = color
                obj.Line.Visible = ESPConfig.Line and onScreen
            end

            -- Name
            if obj.NameText then
                obj.NameText.Text = player.Name
                obj.NameText.Position = Vector2.new(pos.X,pos.Y-20)
                obj.NameText.Color = color
                obj.NameText.Visible = ESPConfig.Name and onScreen
            end

            -- Distance
            if obj.DistanceText then
                obj.DistanceText.Text = string.format("[%.0f]",distance)
                obj.DistanceText.Position = Vector2.new(pos.X,pos.Y-10)
                obj.DistanceText.Color = color
                obj.DistanceText.Visible = ESPConfig.Distance and onScreen
            end
        else
            for k,v in pairs(obj) do
                if type(v)=="table" then
                    for _,l in ipairs(v) do l[2].Visible=false end
                else
                    v.Visible=false
                end
            end
        end
    end

    for player,bar in pairs(HealthBarObjects) do
        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp and humanoid then
            local pos,_ = Camera:WorldToViewportPoint(hrp.Position)
            local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
            local barHeight = math.clamp(3000/distance,20,80)
            local barWidth = 4
            local hpPercent = humanoid.Health/humanoid.MaxHealth
            bar.Size = Vector2.new(barWidth, barHeight*hpPercent)
            bar.Position = Vector2.new(pos.X+25,pos.Y+barHeight*(1-hpPercent)/2 - barHeight/2)
            bar.Color = Color3.fromRGB(255*(1-hpPercent),255*hpPercent,0)
            bar.Visible = ESPConfig.HealthBar and onScreen
        else
            bar.Visible=false
        end
    end
end

local function enableESPLoop()
    for _,plr in ipairs(Players:GetPlayers()) do createESP(plr); createHealthBar(plr) end
    ESPConnection = RunService.RenderStepped:Connect(updateESP)
    Players.PlayerAdded:Connect(function(p) createESP(p); createHealthBar(p) end)
    Players.PlayerRemoving:Connect(function(p) removeESP(p); removeHealthBar(p) end)
end

enableESPLoop()

--================ UI TOGGLE =====================
VisualTab:CreateToggle({Name="ESP Box",CurrentValue=false,Callback=function(v) ESPConfig.Box=v end})
VisualTab:CreateToggle({Name="ESP Skeleton",CurrentValue=false,Callback=function(v) ESPConfig.Skeleton=v end})
VisualTab:CreateToggle({Name="ESP Line",CurrentValue=false,Callback=function(v) ESPConfig.Line=v end})
VisualTab:CreateToggle({Name="ESP Name",CurrentValue=false,Callback=function(v) ESPConfig.Name=v end})
VisualTab:CreateToggle({Name="ESP Distance",CurrentValue=false,Callback=function(v) ESPConfig.Distance=v end})
VisualTab:CreateToggle({Name="ESP Health Bar",CurrentValue=false,Callback=function(v) ESPConfig.HealthBar=v end
