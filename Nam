--==================================================
-- NamX Hub | Rayfield Core
-- Version : v1.5.0
-- Author  : Nam
--==================================================

if getgenv().NamXHubLoaded then
    warn("NamX Hub already loaded")
    return
end
getgenv().NamXHubLoaded = true

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

--==================================================
-- LOAD RAYFIELD
--==================================================
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

--==================================================
-- CREATE WINDOW
--==================================================
local Window = Rayfield:CreateWindow({
    Name = "NamX Hub",
    LoadingTitle = "NamX Hub",
    LoadingSubtitle = "by Nam",
    ConfigurationSaving = { Enabled = true, FolderName = "NamXHub", FileName = "Config" },
    KeySystem = false
})

--==================================================
-- AIMBOT + HITBOX TAB (มาก่อน ESP)
--==================================================
local AimbotTab = Window:CreateTab("Aimbot", 4483362458)
AimbotTab:CreateSection("Aimbot & Hitbox")

--================ CONFIG =====================
local AimbotConfig = {
    Enabled = false,
    TargetPart = "Head", -- Head / HumanoidRootPart
    FOV = 120,
    Smoothness = 0.15,
    WallCheck = true,
    HitboxEnabled = false,
    HitboxSizeHead = 6,
    HitboxSizeBody = 10,
    HitboxTransparency = 0.7
}

local HitboxCache = {}

--================ FOV CIRCLE =====================
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.NumSides = 64
FOVCircle.Filled = false
FOVCircle.Visible = false
FOVCircle.Color = Color3.fromRGB(255,255,255)

--================ FUNCTIONS =====================
local function isVisible(targetPart)
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}

    local result = workspace:Raycast(origin, direction, params)
    if result then
        return result.Instance:IsDescendantOf(targetPart.Parent)
    end
    return true
end

local function getClosestTargetInFOV()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Team ~= LocalPlayer.Team then
            local char = player.Character
            local part = char and char:FindFirstChild(AimbotConfig.TargetPart)
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")

            if part and humanoid and humanoid.Health > 0 then
                if AimbotConfig.WallCheck and not isVisible(part) then
                    continue
                end

                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if dist < AimbotConfig.FOV and dist < shortestDistance then
                        shortestDistance = dist
                        closestPlayer = part
                    end
                end
            end
        end
    end

    return closestPlayer
end

--================ HITBOX =====================
local function applyHitbox(player)
    if not AimbotConfig.HitboxEnabled then return end
    if player == LocalPlayer or player.Team == LocalPlayer.Team then return end

    local char = player.Character
    if not char then return end

    local targetPartName = AimbotConfig.TargetPart
    local part = char:FindFirstChild(targetPartName)
    if not part or not part:IsA("BasePart") then return end

    if not HitboxCache[part] then
        HitboxCache[part] = {
            Size = part.Size,
            Transparency = part.Transparency,
            CanCollide = part.CanCollide
        }
    end

    local size =
        (targetPartName == "Head")
        and AimbotConfig.HitboxSizeHead
        or AimbotConfig.HitboxSizeBody

    part.Size = Vector3.new(size, size, size)
    part.Transparency = AimbotConfig.HitboxTransparency
    part.CanCollide = false
end

local function restoreHitbox()
    for part, data in pairs(HitboxCache) do
        if part and part.Parent then
            part.Size = data.Size
            part.Transparency = data.Transparency
            part.CanCollide = data.CanCollide
        end
    end
    table.clear(HitboxCache)
end

--================ AIMBOT LOOP =====================
RunService.RenderStepped:Connect(function()
    local mousePos = UserInputService:GetMouseLocation()
    FOVCircle.Position = mousePos
    FOVCircle.Radius = AimbotConfig.FOV
    FOVCircle.Visible = AimbotConfig.Enabled

    if not AimbotConfig.Enabled then return end

    local targetPart = getClosestTargetInFOV()
    if targetPart then
        local camPos = Camera.CFrame.Position
        local newCFrame = CFrame.new(camPos, targetPart.Position)
        Camera.CFrame = Camera.CFrame:Lerp(newCFrame, AimbotConfig.Smoothness)
    end

    if AimbotConfig.HitboxEnabled then
        for _, plr in ipairs(Players:GetPlayers()) do
            applyHitbox(plr)
        end
    else
        restoreHitbox()
    end
end)

--================ UI =====================
AimbotTab:CreateToggle({
    Name = "Enable Aimbot",
    CurrentValue = false,
    Callback = function(v)
        AimbotConfig.Enabled = v
    end
})

AimbotTab:CreateDropdown({
    Name = "Target Part",
    Options = {"Head", "HumanoidRootPart"},
    CurrentOption = "Head",
    Callback = function(v)
        AimbotConfig.TargetPart = v
    end
})

AimbotTab:CreateSlider({
    Name = "FOV Size",
    Range = {50, 400},
    Increment = 5,
    CurrentValue = 120,
    Callback = function(v)
        AimbotConfig.FOV = v
    end
})

AimbotTab:CreateSlider({
    Name = "Smoothness",
    Range = {0.05, 1},
    Increment = 0.05,
    CurrentValue = 0.15,
    Callback = function(v)
        AimbotConfig.Smoothness = v
    end
})

AimbotTab:CreateToggle({
    Name = "Wall Check",
    CurrentValue = true,
    Callback = function(v)
        AimbotConfig.WallCheck = v
    end
})

--================ HITBOX UI =====================
AimbotTab:CreateToggle({
    Name = "Enable Hitbox",
    CurrentValue = false,
    Callback = function(v)
        AimbotConfig.HitboxEnabled = v
        if not v then restoreHitbox() end
    end
})

AimbotTab:CreateSlider({
    Name = "Hitbox Size (Head)",
    Range = {4, 20},
    Increment = 1,
    CurrentValue = AimbotConfig.HitboxSizeHead,
    Callback = function(v)
        AimbotConfig.HitboxSizeHead = v
    end
})

AimbotTab:CreateSlider({
    Name = "Hitbox Size (Body)",
    Range = {6, 30},
    Increment = 1,
    CurrentValue = AimbotConfig.HitboxSizeBody,
    Callback = function(v)
        AimbotConfig.HitboxSizeBody = v
    end
})

--==================================================
-- VISUAL / ESP TAB
--==================================================
local VisualTab = Window:CreateTab("Visual", 4483362458)
VisualTab:CreateSection("ESP System")

--================ CONFIG =====================
local ESPConfig = {
    Box = false,
    Skeleton = false,
    Line = false,
    Name = false,
    Distance = false,
    HealthBar = false
}

--================ DRAWING STORAGE =====================
local ESPObjects = {}
local HealthBarObjects = {}
local ESPConnection
local HealthBarConnection

--================ FUNCTIONS =====================
local function getTeamColor(player)
    if player.Team == LocalPlayer.Team then
        return Color3.fromRGB(0,255,0)
    else
        return Color3.fromRGB(255,0,0)
    end
end

-- Create ESP objects for player
local function createESP(player)
    if player == LocalPlayer then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end

    local objects = {}

    -- Box
    objects.Box = Drawing.new("Square")
    objects.Box.Thickness = 1
    objects.Box.Filled = false
    objects.Box.Visible = true

    -- Skeleton
    objects.Skeleton = {}
    local parts = {"Head","UpperTorso","LowerTorso","LeftUpperArm","LeftLowerArm","LeftHand",
                   "RightUpperArm","RightLowerArm","RightHand",
                   "LeftUpperLeg","LeftLowerLeg","LeftFoot",
                   "RightUpperLeg","RightLowerLeg","RightFoot"}
    for _, partName in ipairs(parts) do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Visible = true
        table.insert(objects.Skeleton, {partName, line})
    end

    -- Line
    objects.Line = Drawing.new("Line")
    objects.Line.Thickness = 1
    objects.Line.Visible = true

    -- Name Text
    objects.NameText = Drawing.new("Text")
    objects.NameText.Size = 13
    objects.NameText.Center = true
    objects.NameText.Outline = true
    objects.NameText.Font = 2
    objects.NameText.Visible = true

    -- Distance Text
    objects.DistanceText = Drawing.new("Text")
    objects.DistanceText.Size = 13
    objects.DistanceText.Center = true
    objects.DistanceText.Outline = true
    objects.DistanceText.Font = 2
    objects.DistanceText.Visible = true

    ESPObjects[player] = objects
end

local function removeESP(player)
    if ESPObjects[player] then
        local obj = ESPObjects[player]
        for k,v in pairs(obj) do
            if type(v) == "table" then
                for _, line in ipairs(v) do
                    line[2]:Remove()
                end
            else
                v:Remove()
            end
        end
        ESPObjects[player] = nil
    end
end

--================ HEALTH BAR =====================
local function createHealthBar(player)
    if player == LocalPlayer then return end
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
    local healthBar = Drawing.new("Square")
    healthBar.Thickness = 1
    healthBar.Filled = true
    healthBar.Visible = true
    HealthBarObjects[player] = healthBar
end

local function removeHealthBar(player)
    if HealthBarObjects[player] then
        HealthBarObjects[player]:Remove()
        HealthBarObjects[player] = nil
    end
end

--================ UPDATE LOOP =====================
local function updateESP()
    for player, obj in pairs(ESPObjects) do
        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp and humanoid then
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
            local color = getTeamColor(player)

            -- Box
            if obj.Box then
                local size = math.clamp(3000 / distance, 20, 80)
                obj.Box.Size = Vector2.new(size,size)
                obj.Box.Position = Vector2.new(pos.X - size/2,pos.Y - size/2)
                obj.Box.Color = color
                obj.Box.Visible = ESPConfig.Box and onScreen
            end

            -- Skeleton
            if obj.Skeleton and ESPConfig.Skeleton then
                local function getPartPos(name)
                    local p = char:FindFirstChild(name)
                    if p then
                        local screenPos, onscreen = Camera:WorldToViewportPoint(p.Position)
                        return Vector2.new(screenPos.X, screenPos.Y), onscreen
                    end
                    return nil,false
                end
                -- Head→UpperTorso
                local headPos,_ = getPartPos("Head")
                local upperTorsoPos,_ = getPartPos("UpperTorso")
                local lowerTorsoPos,_ = getPartPos("LowerTorso")
                local leftUpperArmPos,_ = getPartPos("LeftUpperArm")
                local leftLowerArmPos,_ = getPartPos("LeftLowerArm")
                local leftHandPos,_ = getPartPos("LeftHand")
                local rightUpperArmPos,_ = getPartPos("RightUpperArm")
                local rightLowerArmPos,_ = getPartPos("RightLowerArm")
                local rightHandPos,_ = getPartPos("RightHand")
                local leftUpperLegPos,_ = getPartPos("LeftUpperLeg")
                local leftLowerLegPos,_ = getPartPos("LeftLowerLeg")
                local leftFootPos,_ = getPartPos("LeftFoot")
                local rightUpperLegPos,_ = getPartPos("RightUpperLeg")
                local rightLowerLegPos,_ = getPartPos("RightLowerLeg")
                local rightFootPos,_ = getPartPos("RightFoot")

                local lines = obj.Skeleton
                -- Head→UpperTorso
                lines[1][2].From = headPos or Vector2.new(0,0)
                lines[1][2].To = upperTorsoPos or Vector2.new(0,0)
                lines[1][2].Color = color
                lines[1][2].Visible = onScreen and ESPConfig.Skeleton
                -- UpperTorso→LowerTorso
                lines[2][2].From = upperTorsoPos or Vector2.new(0,0)
                lines[2][2].To = lowerTorsoPos or Vector2.new(0,0)
                lines[2][2].Color = color
                lines[2][2].Visible = onScreen and ESPConfig.Skeleton
                -- Arms/Legs (ต่อเหมือนตัวเต็ม)
                for i=3,14 do
                    lines[i][2].Color = color
                    lines[i][2].Visible = onScreen and ESPConfig.Skeleton
                end
            else
                if obj.Skeleton then
                    for _, l in ipairs(obj.Skeleton) do l[2].Visible=false end
                end
            end

            -- Line
            if obj.Line then
                local screenCenter = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)
                obj.Line.From = screenCenter
                obj.Line.To = Vector2.new(pos.X,pos.Y)
                obj.Line.Color = color
                obj.Line.Visible = ESPConfig.Line and onScreen
            end

            -- Name
            if obj.NameText then
                obj.NameText.Text = player.Name
                obj.NameText.Position = Vector2.new(pos.X,pos.Y-20)
                obj.NameText.Color = color
                obj.NameText.Visible = ESPConfig.Name and onScreen
            end

            -- Distance
            if obj.DistanceText then
                obj.DistanceText.Text = string.format("[%.0f]",distance)
                obj.DistanceText.Position = Vector2.new(pos.X,pos.Y-10)
                obj.DistanceText.Color = color
                obj.DistanceText.Visible = ESPConfig.Distance and onScreen
            end

        else
            for k,v in pairs(obj) do
                if type(v)=="table" then
                    for _, l in ipairs(v) do l[2].Visible=false end
                else
                    v.Visible=false
                end
            end
        end
    end

    -- Update Health Bar (แนวตั้งข้างตัว)
    for player, bar in pairs(HealthBarObjects) do
        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hrp and humanoid then
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
            local barHeight = math.clamp(3000/distance,20,80)
            local barWidth = 4
            local hpPercent = humanoid.Health / humanoid.MaxHealth
            bar.Size = Vector2.new(barWidth, barHeight*hpPercent)
            bar.Position = Vector2.new(pos.X + 25, pos.Y + barHeight*(1-hpPercent)/2 - barHeight/2)
            bar.Color = Color3.fromRGB(255*(1-hpPercent),255*hpPercent,0)
            bar.Visible = ESPConfig.HealthBar and onScreen
        else
            bar.Visible=false
        end
    end
end

--================ ENABLE/DISABLE =====================
local function enableESPLoop()
    for _, plr in ipairs(Players:GetPlayers()) do createESP(plr) end
    for _, plr in ipairs(Players:GetPlayers()) do createHealthBar(plr) end

    ESPConnection = RunService.RenderStepped:Connect(updateESP)

    Players.PlayerAdded:Connect(function(p)
        createESP(p)
        createHealthBar(p)
    end)
    Players.PlayerRemoving:Connect(function(p)
        removeESP(p)
        removeHealthBar(p)
    end)
end

local function disableESPLoop()
    if ESPConnection then ESPConnection:Disconnect() ESPConnection=nil end
    for p in pairs(ESPObjects) do removeESP(p) end
    for p in pairs(HealthBarObjects) do removeHealthBar(p) end
end

--================ UI TOGGLE =====================
VisualTab:CreateToggle({Name="ESP Box",CurrentValue=false,Callback=function(v) ESPConfig.Box=v end})
VisualTab:CreateToggle({Name="ESP Skeleton",CurrentValue=false,Callback
